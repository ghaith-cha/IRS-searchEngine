https://en.wikipedia.org/wiki/Functional_programming
For subroutine-oriented programming, see Procedural programming.
Programming paradigm
Programming paradigms
Action
Agent-oriented
Array-oriented
Automata-based
Concurrent computing
Relativistic programming
Data-driven
Declarative (contrast: Imperative)
Functional
Functional logic
Purely functional
Logic
Abductive logic
Answer set
Concurrent logic
Functional logic
Inductive logic
Constraint
Constraint logic
Concurrent constraint logic
Dataflow
Flow-based
Reactive
Ontology
Differentiable
Dynamic/scripting
Event-driven
Function-level (contrast: Value-level)
Point-free style
Concatenative
Generic
Imperative (contrast: Declarative)
Procedural
Object-oriented
Polymorphic
Intentional
Language-oriented
Domain-specific
Literate
Natural-language programming
Metaprogramming
Automatic
Inductive programming
Reflective
Attribute-oriented
Macro
Template
Non-structured (contrast: Structured)
Array
Nondeterministic
Parallel computing
Process-oriented
Probabilistic
Quantum
Set-theoretic
Stack-based
Structured (contrast: Non-structured)
Block-structured
Structured concurrency
Object-oriented
Actor-based
Class-based
Concurrent
Prototype-based
By separation of concerns:
Aspect-oriented
Role-oriented
Subject-oriented
Recursive
Symbolic
Value-level (contrast: Function-level)
v
t
e
In computer science, functional programming is a programming paradigm—a style of building the structure and elements of computer programs—that treats computation as the evaluation of mathematical functions and avoids changing-state and mutable data. It is a declarative programming paradigm in that programming is done with expressions or declarations[1] instead of statements. In functional code, the output value of a function depends only on its arguments, so calling a function with the same value for an argument always produces the same result. This is in contrast to imperative programming where, in addition to a function's arguments, global program state can affect a function's resulting value. Eliminating side effects, that is, changes in state that do not depend on the function inputs, can make understanding a program easier, which is one of the key motivations for the development of functional programming.
Functional programming has its origins in lambda calculus, a formal system developed in the 1930s to investigate computability, the Entscheidungsproblem, function definition, function application, and recursion. Many functional programming languages can be viewed as elaborations on the lambda calculus. Another well-known declarative programming paradigm, logic programming, is based on relations.[2]
In contrast, imperative programming changes state with statements in the source code, the simplest example being assignment. Imperative programming has subroutines, but these are not mathematical functions. They can have side effects that may change a program's state, allowing for functions without return values. Because of this, they lack referential transparency, that is, the same language expression can result in different values at different times depending on the state of the executing program.[2]
Functional programming languages have largely been emphasized in academia rather than industry settings. However, programming languages that support functional programming have been used in industry, including Common Lisp, Scheme,[3][4][5][6] Clojure, Wolfram Language,[7][8] Racket,[9] Erlang,[10][11][12] OCaml,[13][14] Haskell,[15][16] and F#.[17][18] JavaScript, one of the world's most widely distributed languages,[19][20][21] has the properties of a dynamically typed functional language,[20] in addition to imperative and object-oriented paradigms. Functional programming is also key to some languages that have found success in specific domains, like R in statistics,[22][23] J, K and Q in financial analysis, and XQuery/XSLT for XML.[24][25] Domain-specific declarative languages like SQL and Lex/Yacc use some elements of functional programming, especially in not supporting mutable values.[26]
Programming in a functional style can be accomplished in languages that are not specifically designed for functional programming, such as with Perl,[27] PHP,[28] C++11, and Kotlin.[29] A hybrid case is that of Scala[30] – it is frequently written in a functional style, but the presence of side effects and mutable state place it in a grey area between imperative and functional languages.
Contents
1 History
2 Concepts
2.1 First-class and higher-order functions
2.2 Pure functions
2.3 Recursion
2.4 Strict versus non-strict evaluation
2.5 Type systems
2.6 Referential transparency
2.7 Data structures
3 Comparison to imperative programming
3.1 Simulating state
3.2 Efficiency issues
3.3 Coding styles
3.3.1 Java
3.3.2 OCAML
3.3.3 PHP
3.3.4 Python
3.3.5 Wolfram Language
3.3.6 Haskell
3.3.7 Raku
3.3.8 Erlang
3.3.9 Elixir
3.3.10 Lisp
3.3.11 Clojure
3.3.12 Kotlin
3.3.13 Swift
3.3.14 JavaScript
3.3.15 TypeScript
3.3.16 SequenceL
3.3.17 Ruby
3.3.18 Tcl
3.3.19 Go
3.3.20 Scala
3.4 Functional programming in non-functional languages
4 Use in industry
5 In education
6 See also
7 References
8 Further reading
9 External links
History[edit]
Lambda calculus provides a theoretical framework for describing functions and their evaluation. It is a mathematical abstraction rather than a programming language—but it forms the basis of almost all current functional programming languages. An equivalent theoretical formulation, combinatory logic, is commonly perceived as more abstract than lambda calculus and preceded it in invention. Combinatory logic and lambda calculus were both originally developed to achieve a clearer approach to the foundations of mathematics.[31]
An early functional-flavored language was Lisp, developed in the late 1950s for the IBM 700/7000 series scientific computers by John McCarthy while at Massachusetts Institute of Technology (MIT).[32] Lisp first introduced many paradigmatic features of functional programming, though early Lisps were multi-paradigm languages, and incorporated support for numerous programming styles as new paradigms evolved. Later dialects, such as Scheme and Clojure, and offshoots such as Dylan and Julia, sought to simplify and rationalise Lisp around a cleanly functional core, while Common Lisp was designed to preserve and update the paradigmatic features of the numerous older dialects it replaced.[33]
Information Processing Language (IPL), 1956, is sometimes cited as the first computer-based functional programming language.[34] It is an assembly-style language for manipulating lists of symbols. It does have a notion of generator, which amounts to a function that accepts a function as an argument, and, since it is an assembly-level language, code can be data, so IPL can be regarded as having higher-order functions. However, it relies heavily on mutating list structure and similar imperative features.
Kenneth E. Iverson developed APL in the early 1960s, described in his 1962 book A Programming Language (
.mw-parser-output cite.citation{font-style:inherit}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation .cs1-lock-free a{background:url("//upload.wikimedia.org/wikipedia/commons/thumb/6/65/Lock-green.svg/9px-Lock-green.svg.png")no-repeat;background-position:right .1em center}.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:url("//upload.wikimedia.org/wikipedia/commons/thumb/d/d6/Lock-gray-alt-2.svg/9px-Lock-gray-alt-2.svg.png")no-repeat;background-position:right .1em center}.mw-parser-output .citation .cs1-lock-subscription a{background:url("//upload.wikimedia.org/wikipedia/commons/thumb/a/aa/Lock-red-alt-2.svg/9px-Lock-red-alt-2.svg.png")no-repeat;background-position:right .1em center}.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registration{color:#555}.mw-parser-output .cs1-subscription span,.mw-parser-output .cs1-registration span{border-bottom:1px dotted;cursor:help}.mw-parser-output .cs1-ws-icon a{background:url("//upload.wikimedia.org/wikipedia/commons/thumb/4/4c/Wikisource-logo.svg/12px-Wikisource-logo.svg.png")no-repeat;background-position:right .1em center}.mw-parser-output code.cs1-code{color:inherit;background:inherit;border:inherit;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;font-size:100%}.mw-parser-output .cs1-visible-error{font-size:100%}.mw-parser-output .cs1-maint{display:none;color:#33aa33;margin-left:0.3em}.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registration,.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left,.mw-parser-output .cs1-kern-wl-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right,.mw-parser-output .cs1-kern-wl-right{padding-right:0.2em}
ISBN 9780471430148). APL was the primary influence on John Backus's FP. In the early 1990s, Iverson and Roger Hui created J. In the mid-1990s, Arthur Whitney, who had previously worked with Iverson, created K, which is used commercially in financial industries along with its descendant Q.
John Backus presented FP in his 1977 Turing Award lecture "Can Programming Be Liberated From the von Neumann Style? A Functional Style and its Algebra of Programs".[35] He defines functional programs as being built up in a hierarchical way by means of "combining forms" that allow an "algebra of programs"; in modern language, this means that functional programs follow the principle of compositionality.[citation needed] Backus's paper popularized research into functional programming, though it emphasized function-level programming rather than the lambda-calculus style now associated with functional programming.
The 1973 language ML was created by Robin Milner at the University of Edinburgh, and David Turner developed the language SASL at the University of St Andrews. Also in Edinburgh in the 1970s, Burstall and Darlington developed the functional language NPL.[36] NPL was based on Kleene Recursion Equations and was first introduced in their work on program transformation.[37] Burstall, MacQueen and Sannella then incorporated the polymorphic type checking from ML to produce the language Hope.[38] ML eventually developed into several dialects, the most common of which are now OCaml and Standard ML.
Meanwhile, the development of Scheme, a simple lexically scoped and (impurely) functional dialect of Lisp, as described in the influential Lambda Papers and the classic 1985 textbook Structure and Interpretation of Computer Programs, brought awareness of the power of functional programming to the wider programming-languages community.
In the 1980s, Per Martin-Löf developed intuitionistic type theory (also called constructive type theory), which associated functional programs with constructive proofs expressed as dependent types. This led to new approaches to interactive theorem proving and has influenced the development of subsequent functional programming languages.[citation needed]
The lazy functional language, Miranda, developed by David Turner, initially appeared in 1985 and had a strong influence on Haskell. With Miranda being proprietary, Haskell began with a consensus in 1987 to form an open standard for functional programming research; implementation releases have been ongoing since 1990.
More recently it has found use in niches such as parametric CAD courtesy of the OpenSCAD language built on the CSG geometry framework, although its inability to reassign values has led to much confusion among users who are often unfamiliar with Functional programming as a concept.[39]
Functional programming continues to be used in commercial settings.[40][41][42]
Concepts[edit]
A number of concepts and paradigms are specific to functional programming, and generally foreign to imperative programming (including object-oriented programming). However, programming languages often cater to several programming paradigms, so programmers using "mostly imperative" languages may have utilized some of these concepts.[43]
First-class and higher-order functions[edit]
Main articles: First-class function and Higher-order function
Higher-order functions are functions that can either take other functions as arguments or return them as results. In calculus, an example of a higher-order function is the differential operator
d
/
d
x
{\displaystyle d/dx}
, which returns the derivative of a function
f
{\displaystyle f}
.
Higher-order functions are closely related to first-class functions in that higher-order functions and first-class functions both allow functions as arguments and results of other functions. The distinction between the two is subtle: "higher-order" describes a mathematical concept of functions that operate on other functions, while "first-class" is a computer science term that describes programming language entities that have no restriction on their use (thus first-class functions can appear anywhere in the program that other first-class entities like numbers can, including as arguments to other functions and as their return values).
Higher-order functions enable partial application or currying, a technique that applies a function to its arguments one at a time, with each application returning a new function that accepts the next argument. This lets a programmer succinctly express, for example, the successor function as the addition operator partially applied to the natural number one.
Pure functions[edit]
Pure functions (or expressions) have no side effects (memory or I/O). This means that pure functions have several useful properties, many of which can be used to optimize the code:
If the result of a pure expression is not used, it can be removed without affecting other expressions.
If a pure function is called with arguments that cause no side-effects, the result is constant with respect to that argument list (sometimes called referential transparency), i.e., calling the pure function again with the same arguments returns the same result. (This can enable caching optimizations such as memoization.)
If there is no data dependency between two pure expressions, their order can be reversed, or they can be performed in parallel and they cannot interfere with one another (in other terms, the evaluation of any pure expression is thread-safe).
If the entire language does not allow side-effects, then any evaluation strategy can be used; this gives the compiler freedom to reorder or combine the evaluation of expressions in a program (for example, using deforestation).
While most compilers for imperative programming languages detect pure functions and perform common-subexpression elimination for pure function calls, they cannot always do this for pre-compiled libraries, which generally do not expose this information, thus preventing optimizations that involve those external functions. Some compilers, such as gcc, add extra keywords for a programmer to explicitly mark external functions as pure, to enable such optimizations. Fortran 95 also lets functions be designated pure.[44] C++11 added constexpr keyword with similar semantics.
Recursion[edit]
Main article: Recursion (computer science)
Iteration (looping) in functional languages is usually accomplished via recursion. Recursive functions invoke themselves, letting an operation be repeated until it reaches the base case. Although some recursion requires maintaining a stack, tail recursion can be recognized and optimized by a compiler into the same code used to implement iteration in imperative languages. The Scheme language standard requires implementations to recognize and optimize tail recursion. Tail recursion optimization can be implemented by transforming the program into continuation passing style during compiling, among other approaches.
Common patterns of recursion can be abstracted away using higher-order functions, with catamorphisms and anamorphisms (or "folds" and "unfolds") being the most obvious examples. Such recursion schemes play a role analogous to built-in control structures such as loops in imperative languages.
Most general purpose functional programming languages allow unrestricted recursion and are Turing complete, which makes the halting problem undecidable, can cause unsoundness of equational reasoning, and generally requires the introduction of inconsistency into the logic expressed by the language's type system. Some special purpose languages such as Coq allow only well-founded recursion and are strongly normalizing (nonterminating computations can be expressed only with infinite streams of values called codata). As a consequence, these languages fail to be Turing complete and expressing certain functions in them is impossible, but they can still express a wide class of interesting computations while avoiding the problems introduced by unrestricted recursion. Functional programming limited to well-founded recursion with a few other constraints is called total functional programming.[45]
Strict versus non-strict evaluation[edit]
Main article: Evaluation strategy
Functional languages can be categorized by whether they use strict (eager) or non-strict (lazy) evaluation, concepts that refer to how function arguments are processed when an expression is being evaluated. The technical difference is in the denotational semantics of expressions containing failing or divergent computations. Under strict evaluation, the evaluation of any term containing a failing subterm fails. For example, the expression:
print length([2+1, 3*2, 1/0, 5-4])
fails under strict evaluation because of the division by zero in the third element of the list. Under lazy evaluation, the length function returns the value 4 (i.e., the number of items in the list), since evaluating it does not attempt to evaluate the terms making up the list. In brief, strict evaluation always fully evaluates function arguments before invoking the function. Lazy evaluation does not evaluate function arguments unless their values are required to evaluate the function call itself.
The usual implementation strategy for lazy evaluation in functional languages is graph reduction.[46] Lazy evaluation is used by default in several pure functional languages, including Miranda, Clean, and Haskell.
Hughes 1984 argues for lazy evaluation as a mechanism for improving program modularity through separation of concerns, by easing independent implementation of producers and consumers of data streams.[47] Launchbury 1993 describes some difficulties that lazy evaluation introduces, particularly in analyzing a program's storage requirements, and proposes an operational semantics to aid in such analysis.[48] Harper 2009 proposes including both strict and lazy evaluation in the same language, using the language's type system to distinguish them.[49]
Type systems[edit]
Especially since the development of Hindley–Milner type inference in the 1970s, functional programming languages have tended to use typed lambda calculus, rejecting all invalid programs at compilation time and risking false positive errors, as opposed to the untyped lambda calculus, that accepts all valid programs at compilation time and risks false negative errors, used in Lisp and its variants (such as Scheme), though they reject all invalid programs at runtime, when the information is enough to not reject valid programs. The use of algebraic datatypes makes manipulation of complex data structures convenient; the presence of strong compile-time type checking makes programs more reliable in absence of other reliability techniques like test-driven development, while type inference frees the programmer from the need to manually declare types to the compiler in most cases.
Some research-oriented functional languages such as Coq, Agda, Cayenne, and Epigram are based on intuitionistic type theory, which lets types depend on terms. Such types are called dependent types. These type systems do not have decidable type inference and are difficult to understand and program with.[50][51][52][53] But dependent types can express arbitrary propositions in predicate logic. Through the Curry–Howard isomorphism, then, well-typed programs in these languages become a means of writing formal mathematical proofs from which a compiler can generate certified code. While these languages are mainly of interest in academic research (including in formalized mathematics), they have begun to be used in engineering as well. Compcert is a compiler for a subset of the C programming language that is written in Coq and formally verified.[54]
A limited form of dependent types called generalized algebraic data types (GADT's) can be implemented in a way that provides some of the benefits of dependently typed programming while avoiding most of its inconvenience.[55] GADT's are available in the Glasgow Haskell Compiler, in OCaml (since version 4.00) and in Scala (as "case classes"), and have been proposed as additions to other languages including Java and C#.[56]
Referential transparency[edit]
Main article: Referential transparency
Functional programs do not have assignment statements, that is, the value of a variable in a functional program never changes once defined. This eliminates any chances of side effects because any variable can be replaced with its actual value at any point of execution. So, functional programs are referentially transparent.[57]
Consider C assignment statement x = x * 10, this changes the value assigned to the variable x. Let us say that the initial value of x was 1, then two consecutive evaluations of the variable x yields 10 and 100 respectively. Clearly, replacing x = x * 10 with either 10 or 100 gives a program with different meaning, and so the expression is not referentially transparent. In fact, assignment statements are never referentially transparent.
Now, consider another function such as int plusone(int x) {return x+1;} is transparent, as it does not implicitly change the input x and thus has no such side effects. Functional programs exclusively use this type of function and are therefore referentially transparent.
Data structures[edit]
Main article: Purely functional data structure
Purely functional data structures are often represented in a different way than their imperative counterparts.[58] For example, the array with constant access and update times is a basic component of most imperative languages, and many imperative data-structures, such as the hash table and binary heap, are based on arrays. Arrays can be replaced by maps or random access lists, which admit purely functional implementation, but have logarithmic access and update times. Purely functional data structures have persistence, a property of keeping previous versions of the data structure unmodified. In Clojure, persistent data structures are used as functional alternatives to their imperative counterparts. Persistent vectors, for example, use trees for partial updating. Calling the insert method will result in some but not all nodes being created.[59]
Comparison to imperative programming[edit]
Functional programming is very different from imperative programming. The most significant differences stem from the fact that functional programming avoids side effects, which are used in imperative programming to implement state and I/O. Pure functional programming completely prevents side-effects and provides referential transparency.
Higher-order functions are rarely used in older imperative programming. A traditional imperative program might use a loop to traverse and modify a list. A functional program, on the other hand, would probably use a higher-order “map” function that takes a function and a list, generating and returning a new list by applying the function to each list item.
Simulating state[edit]
There are tasks (for example, maintaining a bank account balance) that often seem most naturally implemented with state. Pure functional programming performs these tasks, and I/O tasks such as accepting user input and printing to the screen, in a different way.
The pure functional programming language Haskell implements them using monads, derived from category theory. Monads offer a way to abstract certain types of computational patterns, including (but not limited to) modeling of computations with mutable state (and other side effects such as I/O) in an imperative manner without losing purity. While existing monads may be easy to apply in a program, given appropriate templates and examples, many students find them difficult to understand conceptually, e.g., when asked to define new monads (which is sometimes needed for certain types of libraries).[60]
Functional languages also simulate states by passing around immutable states. This can be done by making a function accept the state as one of its parameters, and return a new state together with the result, leaving the old state unchanged.[61]
Impure functional languages usually include a more direct method of managing mutable state. Clojure, for example, uses managed references that can be updated by applying pure functions to the current state. This kind of approach enables mutability while still promoting the use of pure functions as the preferred way to express computations.[citation needed]
Alternative methods such as Hoare logic and uniqueness have been developed to track side effects in programs. Some modern research languages use effect systems to make the presence of side effects explicit.[citation needed]
Efficiency issues[edit]
Functional programming languages are typically less efficient in their use of CPU and memory than imperative languages such as C and Pascal.[62] This is related to the fact that some mutable data structures like arrays have a very straightforward implementation using present hardware (which is a highly evolved Turing machine). Flat arrays may be accessed very efficiently with deeply pipelined CPUs, prefetched efficiently through caches (with no complex pointer chasing), or handled with SIMD instructions. It is also not easy to create their equally efficient general-purpose immutable counterparts. For purely functional languages, the worst-case slowdown is logarithmic in the number of memory cells used, because mutable memory can be represented by a purely functional data structure with logarithmic access time (such as a balanced tree).[63] However, such slowdowns are not universal. For programs that perform intensive numerical computations, functional languages such as OCaml and Clean are only slightly slower than C according to The Computer Language Benchmarks Game.[64] For programs that handle large matrices and multidimensional databases, array functional languages (such as J and K) were designed with speed optimizations.
Immutability of data can in many cases lead to execution efficiency by allowing the compiler to make assumptions that are unsafe in an imperative language, thus increasing opportunities for inline expansion.[65]
Lazy evaluation may also speed up the program, even asymptotically, whereas it may slow it down at most by a constant factor (however, it may introduce memory leaks if used improperly). Launchbury 1993[48] discusses theoretical issues related to memory leaks from lazy evaluation, and O'Sullivan et al. 2008[66] give some practical advice for analyzing and fixing them. However, the most general implementations of lazy evaluation making extensive use of dereferenced code and data perform poorly on modern processors with deep pipelines and multi-level caches (where a cache miss may cost hundreds of cycles)[citation needed].
Coding styles[edit]
This section does not cite any sources. Please help improve this section by adding citations to reliable sources. Unsourced material may be challenged and removed.
Find sources: "Functional programming" – news · newspapers · books · scholar · JSTOR (July 2013) (Learn how and when to remove this template message)
Imperative programs have the environment and a sequence of steps manipulating the environment. Functional programs have an expression that is successively substituted until it reaches normal form. An example illustrates this with different solutions to the same programming goal (calculating Fibonacci numbers).
Java[edit]
Get Fibonacci number
public UnaryOperator<Integer> fib(Integer acc, Integer incr) { return x -> { return (x > 0) ? fib(acc + incr, acc).apply(--x) : acc; }; } System.out.println(fib(1, 0).apply(5));
OCAML[edit]
Printing first 10 Fibonacci numbers
let fib_list = let rec fib_list_aux first second = function | 0 -> [] | x -> first::fib_list_aux second (first+second) (x-1) in fib_list_aux 0 1 let () = List.iter (Printf.printf "%d ") (fib_list 10)
PHP[edit]
Printing first 10 Fibonacci numbers, using function
function fib(int $n): int { return ($n === 0 || $n === 1) ? $n : fib($n - 1) + fib($n - 2); } for ($i = 0; $i <= 10; $i++) echo fib($i) . PHP_EOL;
Printing first 10 Fibonacci numbers, using closure
$fib = function(int $n) use(&$fib): int { return ($n === 0 || $n === 1) ? $n : $fib($n - 1) + $fib($n - 2); }; for ($i = 0; $i <= 10; $i++) echo $fib($i) . PHP_EOL;
Printing a list with first 10 Fibonacci numbers, with generators
function fib(int $n): iterable { yield 0; $n--; yield 1; $n--; $second = ($first = 2) + 1; while ($n-- !== 0) { yield $first; [$second, $first] = [$first + $second, $second]; } } $fibo = fib(10); foreach ($fibo as $value) { echo $value . PHP_EOL; }
Python[edit]
Printing a list of the first 10 Fibonacci numbers, iterative
def fibonacci(n, first: int = 0, second: int = 1) -> None: for _ in range(n): print(first) # Side-effect first, second = second, first + second # Assignment fibonacci(10)
Printing a list of the first 10 Fibonacci numbers, functional expression style
fibonacci = (lambda n, first=0, second=1: "" if n == 0 else str(first) + "\n" + fibonacci(n - 1, second, first + second)) print(fibonacci(10), end="")
Printing a list of the first 10 Fibonacci numbers, with generators
def fibonacci(n, first: int = 0, second: int = 1): for _ in range(n): yield first first, second = second, first + second # Assignment print(list(fibonacci(10)))
Printing a list of the first 10 Fibonacci numbers, functional expression style
fibonacci = (lambda n, first=0, second=1: [] if n == 0 else [first] + fibonacci(n - 1, second, first + second)) print(fibonacci(10))
Printing a list of the first 10 Fibonacci numbers, recursive style
def fibonacci(int: n) -> int: if n <= 1: return n else: return fibonacci(n-2) + fibonacci(n-1) for n in range(10): print(fibonacci(n))
Wolfram Language[edit]
Printing first 10 Fibonacci numbers,functional expression style[1]
Fibonacci/@Range[10]
Or, alternatively, in a more functional programming approach:
If[# <= 2, 1, #0[# - 1] + #0[# - 2]] & /@ Range[10]
Notice the use of #0 to indicate the function itself.
Haskell[edit]
Printing first 10 Fibonacci numbers, functional expression style[1]
fibonacci_aux = \n first second-> if n == 0 then "" else show first ++ "\n" ++ fibonacci_aux (n - 1) second (first + second) fibonacci = \n-> fibonacci_aux n 0 1 main = putStr (fibonacci 10)
Printing a list with first 10 Fibonacci numbers, functional expression style[1]
fibonacci_aux = \n first second-> if n == 0 then [] else [first] ++ fibonacci_aux (n - 1) second (first + second) fibonacci = \n-> fibonacci_aux n 0 1 main = putStrLn (show (fibonacci 10))
Printing the 11th Fibonacci number, functional expression style[1]
fibonacci = \n-> if n == 0 then 0 else if n == 1 then 1 else fibonacci(n - 1) + fibonacci(n - 2) main = putStrLn (show (fibonacci 10))
Printing the 11th Fibonacci number, functional expression style,[1] tail recursive
fibonacci_aux = \n first second-> if n == 0 then first else fibonacci_aux (n - 1) second (first + second) fibonacci = \n-> Fibonacci_aux n 0 1 main = putStrLn (show (fibonacci 10))
Printing the 11th Fibonacci number, functional expression style[1] with recursive lists
fibonacci_aux = \first second-> first : fibonacci_aux second (first + second) select = \n zs-> if n==0 then head zs else select (n - 1) (tail zs) fibonacci = \n-> select n (fibonacci_aux 0 1) main = putStrLn (show (fibonacci 10))
Printing the 11th Fibonacci number, functional expression style[1] with primitives for recursive lists
fibonacci_aux = \first second-> first : fibonacci_aux second (first + second) fibonacci = \n-> (fibonacci_aux 0 1) !! n main = putStrLn (show (fibonacci 10))
Printing the 11th Fibonacci number, functional expression style[1] with primitives for recursive lists, more concisely
fibonacci_aux = 0:1:zipWith (+) fibonacci_aux (tail fibonacci_aux) fibonacci = \n-> fibonacci_aux !! n main = putStrLn (show (fibonacci 10))
Printing the 11th Fibonacci number, functional declaration style[1]
fibonacci 0 = 0 fibonacci 1 = 1 fibonacci n = fibonacci (n-1) + fibonacci (n-2) main = putStrLn (show (fibonacci 10))
Printing the 11th Fibonacci number, functional declaration style,[1] tail recursive
fibonacci_aux 0 first _ = first fibonacci_aux n first second = fibonacci_aux (n - 1) second (first + second) fibonacci n = fibonacci_aux n 0 1 main = putStrLn (show (fibonacci 10))
Printing the 11th Fibonacci number, functional declaration style, using lazy infinite lists and primitives
fibs = 1 : 1 : zipWith (+) fibs (tail fibs) -- an infinite list of the fibonacci numbers -- fibs is defined in terms of fibs fibonacci = (fibs !!) main = putStrLn $ show $ fibonacci 11
Printing the first 10 Fibonacci numbers, list comprehension (generator) style
fibs = [0, 1] ++ [(fibs !! x) + (fibs !! (x + 1)) | x <- [0..]] main = putStrLn $ show $ take 10 fibs
Raku[edit]
As influenced by Haskell and others, Raku has several functional and declarative approaches to problems. For example, you can declaratively build up a well-typed recursive version (the type constraints are optional) through signature pattern matching:
# define constraints that are common to all candidates proto fib ( UInt:D \n --> UInt:D ) {*} multi fib ( 0 --> 0 ) { } multi fib ( 1 --> 1 ) { } multi fib ( \n ) { fib(n - 1) + fib(n - 2) } for ^10 -> $n { say fib($n) }
An alternative to this is to construct a lazy iterative sequence, which appears as an almost direct illustration of the sequence:
my @fib = 0, 1, *+* ... *; # Each additional entry is the sum of the previous two # and this sequence extends lazily indefinitely say @fib[^10]; # Display the first 10 entries
Erlang[edit]
Erlang is a functional, concurrent, general-purpose programming language. A Fibonacci algorithm implemented in Erlang (Note: This is only for demonstrating the Erlang syntax. Use other algorithms for fast performance[67]):
-module(fib). % This is the file 'fib.erl', the module and the filename must match -export([fib/1]). % This exports the function 'fib' of arity 1 fib(1) -> 1; % If 1, then return 1, otherwise (note the semicolon ; meaning 'else') fib(2) -> 1; % If 2, then return 1, otherwise fib(N) -> fib(N - 2) + fib(N - 1).
Elixir[edit]
Elixir is a functional, concurrent, general-purpose programming language that runs on the Erlang virtual machine (BEAM).
The Fibonacci function can be written in Elixir as follows:
defmodule Fibonacci do def fib(0), do: 0 def fib(1), do: 1 def fib(n), do: fib(n-1) + fib(n-2) end Enum.map(1..10, &Fibonacci.fib/1)
Lisp[edit]
The Fibonacci function can be written in Common Lisp as follows:
(defun fib (n &optional (a 0) (b 1)) (if (= n 0) a (fib (- n 1) b (+ a b))))
or
(defun fib (n) (if (or (= n 0) (= n 1)) n (+ (fib (- n 1)) (fib (- n 2)))))
The program can then be called as
(fib 10)
Clojure[edit]
The Fibonacci function can be written in Clojure as follows:
(defn fib [n] (loop [a 0 b 1 i n] (if (zero? i) a (recur b (+ a b) (dec i)))))
The program can then be called as
(fib 7)
Explicitly using "lazy-seq", the infinite sequence of Fibonacci numbers can be defined recursively.
;; lazy infinite sequence (def fibs (cons 0 (cons 1 (lazy-seq (map + fibs (rest fibs)))))) ;; list of first 10 Fibonacci numbers taken from infinite sequence (take 10 fibs)
Kotlin[edit]
The Fibonacci function can be written in Kotlin as follows:
fun fib(x: Int): Int = if (x in 0..1) x else fib(x - 1) + fib(x - 2)
The program can then be called as
fib(7)
Swift[edit]
The Fibonacci function can be written in Swift as follows:
func fib(_ x: Int) -> Int { if x == 0 || x == 1 { return x } else { return fib(x - 1) + fib(x - 2) } }
The function can then be called as
fib(7)
JavaScript[edit]
The Fibonacci function can be written in JavaScript as follows:
const fib = (x) => (function sub_fib(a, b) { return x-- > 0 ? sub_fib(b, a+b) : a})(0,1)
or
const fib = (x, a = 0, b = 1) => x > 0 ? fib(x - 1, b, a + b) : a
or
const fib = x => x <= 0 ? 0 : x === 1 ? 1 : fib(x - 1) + fib(x - 2)
or
const fib = (f => f(f))(f => x => x <= 0 ? 0 : x === 1 ? 1 : f(f)(x - 1) + f(f)(x - 2))
TypeScript[edit]
The Fibonacci function can be written in TypeScript as follows:
const fib = (x: number): number => x <= 0 ? 0 : x === 1 ? x : fib(x - 1) + fib(x - 2)
SequenceL[edit]
SequenceL is a functional, concurrent, general-purpose programming language. The Fibonacci function can be written in SequenceL as follows:
fib(n) := n when n < 2 else fib(n - 1) + fib(n - 2);
The function can then be called as
fib(10)
To reduce the memory consumed by the call stack when computing a large Fibonacci term, a tail-recursive version can be used. A tail-recursive function is implemented by the SequenceL compiler as a memory-efficient looping structure:
fib(n) := fib_Helper(0, 1, n); fib_Helper(prev, next, n) := prev when n < 1 else next when n = 1 else fib_Helper(next, next + prev, n - 1);
Ruby[edit]
The Fibonacci function can be written in ruby using lambdas as follows:
fib = -> n { (n == 0 || n == 1) ? n : fib[n - 1] + fib[n - 2] }
or
fib = ( -> f { f[f] } )[ -> f { -> n { (n == 0 || n == 1) ? n : f[f][n - 1] + f[f][n - 2] } } ]
Tcl[edit]
The Fibonacci function can be written in Tcl as a recursive function as follows:
proc fibo {x} { expr {$x<2? $x: [fibo [expr {$x-1}]] + [fibo [expr {$x-2}]]} }
Go[edit]
The Fibonacci function can be written in Go as follows:
An example of a recursive style
func Fibonacci(n uint) uint { if n <= 1 { return n } return Fibonacci(n-1) + Fibonacci(n-2) }
An example of a more performant sequential style
func Fibonacci(n uint) uint { if n <= 1 { return n } var n2, n1 uint = 0, 1 for i := uint(2); i < n; i++ { n2, n1 = n1, n1+n2 } return n2 + n1 }
Scala[edit]
The Fibonacci function can be written in Scala in several ways (assuming n is non-negative):
Imperative "Java" style
def fibImp(n: Int): Int = { var i = 0 var j = 1 for (k <- 0 until n) { val l = i + j i = j j = l } i }
Recursive style, slow
def fibRec(n: Int): Int = n match { case 0 => 0 case 1 => 1 case _ => fibRec(n - 1) + fibRec(n - 2) }
Recursive style with tail call optimization, fast
def fibTailRec(n: Int): Int = { @tailrec def fib(i: Int, v: Int, vNext: Int): Int = if (i == n) v else fib(i + 1, vNext, v + vNext) fib(0, 0, 1) }
Using Scala streams
val fibStream: Stream[Int] = 0 #:: 1 #:: (fibStream zip fibStream.tail).map(n => n._1 + n._2)
Functional programming in non-functional languages[edit]
It is possible to use a functional style of programming in languages that are not traditionally considered functional languages.[68] For example, both D[69] and Fortran 95[44] explicitly support pure functions.
JavaScript, Lua[70] and Python had first class functions from their inception.[71] Python had support for "lambda", "map", "reduce", and "filter" in 1994, as well as closures in Python 2.2,[72] though Python 3 relegated "reduce" to the functools standard library module.[73] First-class functions have been introduced into other mainstream languages such as PHP 5.3, Visual Basic 9, C# 3.0, C++11, and Kotlin.[29][citation needed]
In PHP, anonymous classes, closures and lambdas are fully supported. Libraries and language extensions for immutable data structures are being developed to aid programming in the functional style.
In Java, anonymous classes can sometimes be used to simulate closures;[74] however, anonymous classes are not always proper replacements to closures because they have more limited capabilities.[75] Java 8 supports lambda expressions as a replacement for some anonymous classes.[76] However, the presence of checked exceptions in Java can make functional programming inconvenient, because it can be necessary to catch checked exceptions and then rethrow them—a problem that does not occur in other JVM languages that do not have checked exceptions, such as Scala.[citation needed]
In C#, anonymous classes are not necessary, because closures and lambdas are fully supported. Libraries and language extensions for immutable data structures are being developed to aid programming in the functional style in C#.
Many object-oriented design patterns are expressible in functional programming terms: for example, the strategy pattern simply dictates use of a higher-order function, and the visitor pattern roughly corresponds to a catamorphism, or fold.
Similarly, the idea of immutable data from functional programming is often included in imperative programming languages,[77] for example the tuple in Python, which is an immutable array.
Use in industry[edit]
Functional programming has long been popular in academia, but with few industrial applications.[78]:page 11 However, recently several prominent functional programming languages have been used in commercial or industrial systems.[79] For example, the Erlang programming language, which was developed by the Swedish company Ericsson in the late 1980s, was originally used to implement fault-tolerant telecommunications systems.[11] It has since become popular for building a range of applications at companies such as Nortel, Facebook, Électricité de France and WhatsApp.[10][12][80][81][82] The Scheme dialect of Lisp was used as the basis for several applications on early Apple Macintosh computers,[3][4] and has more recently been applied to problems such as training simulation software[5] and telescope control.[6] OCaml, which was introduced in the mid-1990s, has seen commercial use in areas such as financial analysis,[13] driver verification, industrial robot programming, and static analysis of embedded software.[14] Haskell, though initially intended as a research language,[16] has also been applied by a range of companies, in areas such as aerospace systems, hardware design, and web programming.[15][16]
Other functional programming languages that have seen use in industry include Scala,[83] F#,[17][18] (both being functional-OO hybrids with support for both purely functional and imperative programming) Wolfram Language,[7] Lisp,[84] Standard ML[85][86] and Clojure.[87]
In education[edit]
Functional programming is being used as a method to teach problem solving, algebra and geometric concepts.[88] It has also been used as a tool to teach classical mechanics in Structure and Interpretation of Classical Mechanics.
See also[edit]
Computer programming portal
Purely functional programming
Comparison of programming paradigms
Eager evaluation
List of functional programming topics
Nested function
Inductive functional programming
Functional reactive programming
References[edit]
^ a b c d e f g h i j k "Declaration vs. expression style - HaskellWiki".
^ a b Hudak, Paul (September 1989). "Conception, evolution, and application of functional programming languages" (PDF). ACM Computing Surveys. 21 (3): 359–411. doi:10.1145/72551.72554.
^ a b Clinger, Will (1987). "MultiTasking and MacScheme". MacTech. 3 (12). Retrieved 2008-08-28.
^ a b Hartheimer, Anne (1987). "Programming a Text Editor in MacScheme+Toolsmith". MacTech. 3 (1). Archived from the original on 2011-06-29. Retrieved 2008-08-28.
^ a b Kidd, Eric. Terrorism Response Training in Scheme. CUFP 2007. Retrieved 2009-08-26.
^ a b Cleis, Richard. Scheme in Space. CUFP 2006. Retrieved 2009-08-26.
^ a b "Wolfram Language Guide: Functional Programming". 2015. Retrieved 2015-08-24.
^ "Functional vs. Procedural Programming Language". Department of Applied Math. University of Colorado. Archived from the original on 2007-11-13.
^ "State-Based Scripting in Uncharted 2" (PDF). Archived from the original (PDF) on 2012-12-15. Retrieved 2011-08-08.
^ a b "Who uses Erlang for product development?". Frequently asked questions about Erlang. Retrieved 2018-04-27.
^ a b Armstrong, Joe (June 2007). A history of Erlang. Third ACM SIGPLAN Conference on History of Programming Languages. San Diego, California. doi:10.1145/1238844.1238850.
^ a b Larson, Jim (March 2009). "Erlang for concurrent programming". Communications of the ACM. 52 (3): 48. doi:10.1145/1467247.1467263.
^ a b Minsky, Yaron; Weeks, Stephen (July 2008). "Caml Trading — experiences with functional programming on Wall Street". Journal of Functional Programming. 18 (4): 553–564. doi:10.1017/S095679680800676X. Retrieved 2008-08-27.
^ a b Leroy, Xavier. Some uses of Caml in Industry (PDF). CUFP 2007. Retrieved 2009-08-26.
^ a b "Haskell in industry". Haskell Wiki. Retrieved 2009-08-26. Haskell has a diverse range of use commercially, from aerospace and defense, to finance, to web startups, hardware design firms and lawnmower manufacturers.
^ a b c Hudak, Paul; Hughes, J.; Jones, S. P.; Wadler, P. (June 2007). A history of Haskell: being lazy with class. Third ACM SIGPLAN Conference on History of Programming Languages. San Diego, California. doi:10.1145/1238844.1238856. Retrieved 2013-09-26.
^ a b Mansell, Howard (2008). Quantitative Finance in F#. CUFP 2008. Retrieved 2009-08-29.
^ a b Peake, Alex (2009). The First Substantial Line of Business Application in F#. CUFP 2009. Archived from the original on 2009-10-17. Retrieved 2009-08-29.
^ "The 15 most popular computer languages, according to the Facebook for programmers". 2016. Retrieved 2017-07-31.
^ a b "JavaScript is the World's Dominant Programming Language". 2016. Retrieved 2017-07-31.
^ "Concepts of Functional Programming in Javascript". 2018. Retrieved 2019-03-07.
^ "The useR! 2006 conference schedule includes papers on the commercial use of R". R-project.org. 2006-06-08. Retrieved 2011-06-20.
^ Chambers, John M. (1998). Programming with Data: A Guide to the S Language. Springer Verlag. pp. 67–70. ISBN
978-0-387-98503-9
.
^ Dimitre Novatchev. "The Functional Programming Language XSLT — A proof through examples". TopXML. Retrieved May 27, 2006.
^ David Mertz. "XML Programming Paradigms (part four): Functional Programming approached to XML processing". IBM developerWorks. Retrieved May 27, 2006.
^ Donald D. Chamberlin and Raymond F. Boyce (1974). "SEQUEL: A structured English query language". Proceedings of the 1974 ACM SIGFIDET: 249–264.
^ Dominus, Mark J. (2005). Higher-Order Perl. Morgan Kaufmann. ISBN
978-1-55860-701-9
.
^ Holywell, Simon (2014). Functional Programming in PHP. php[architect]. ISBN
9781940111056
.
^ a b "Functional programming - Kotlin Programming Language". Kotlin. Retrieved 2019-05-01.
^ "Effective Scala". Scala Wiki. Retrieved 2012-02-21. Effective Scala.
^ Haskell Brooks Curry; Robert Feys (1958). Combinatory Logic. North-Holland Publishing Company. Retrieved 10 February 2013.
^ McCarthy, John (June 1978). "History of Lisp". In ACM/SIGPLAN History of Programming Languages Conference: 217–223. doi:10.1145/800025.808387.
^ Guy L. Steele; Richard P. Gabriel (February 1996). The Evolution of Lisp (PDF). In ACM/SIGPLAN Second History of Programming Languages. pp. 233–330. doi:10.1145/234286.1057818. ISBN
978-0-201-89502-5
.
^ The memoir of Herbert A. Simon (1991), Models of My Life pp.189-190
ISBN 0-465-04640-1 claims that he, Al Newell, and Cliff Shaw are "...commonly adjudged to be the parents of [the] artificial intelligence [field]," for writing Logic Theorist, a program that proved theorems from Principia Mathematica automatically. To accomplish this, they had to invent a language and a paradigm that, viewed retrospectively, embeds functional programming.
^ "Can Programming Be Liberated from the von Neumann Style? A Functional Style and Its Algebra of Programs" (PDF).
^ R.M. Burstall. Design considerations for a functional programming language. Invited paper, Proc. Infotech State of the Art Conf. "The Software Revolution", Copenhagen, 45–57 (1977)
^ R.M. Burstall and J. Darlington. A transformation system for developing recursive programs. Journal of the Association for Computing Machinery 24(1):44–67 (1977)
^ R.M. Burstall, D.B. MacQueen and D.T. Sannella. HOPE: an experimental applicative language. Proc. 1980 LISP Conference, Stanford, 136–143 (1980).
^ "Make discovering assign() easier!". OpenSCAD.
^ Peter Bright (March 13, 2018). "Developers love trendy new languages but earn more with functional programming". Ars Technica.
^ John Leonard (January 24, 2017). "The stealthy rise of functional programming". Computing.
^ Leo Cheung (May 9, 2017). "Is functional programming better for your startup?". InfoWorld.
^ Dick Pountain. "Functional Programming Comes of Age". BYTE.com (August 1994). Archived from the original on 2006-08-27. Retrieved August 31, 2006.
^ a b "ISO/IEC JTC 1/SC 22/WG5/N2137". International Organization for Standardization. July 6, 2017. Cite journal requires |journal= (help)
^ Turner, D.A. (2004-07-28). "Total Functional Programming". Journal of Universal Computer Science. 10 (7): 751–768. doi:10.3217/jucs-010-07-0751.
^ The Implementation of Functional Programming Languages. Simon Peyton Jones, published by Prentice Hall, 1987
^ Hughes, John (1984). "Why Functional Programming Matters".
^ a b John Launchbury (1993). "A Natural Semantics for Lazy Evaluation". CiteSeerX 10.1.1.35.2016. Cite journal requires |journal= (help)
^ Robert W. Harper (2009). Practical Foundations for Programming Languages (PDF). Archived from the original (PDF) on 2016-04-07.
^ Huet, Gérard P. (1973). "The Undecidability of Unification in Third Order Logic". Information and Control. 22 (3): 257–267. doi:10.1016/s0019-9958(73)90301-x.
^ Huet, Gérard (Sep 1976). Resolution d'Equations dans des Langages d'Ordre 1,2,...ω (Ph.D.) (in French). Universite de Paris VII.
^ Huet, Gérard (2002). "Higher Order Unification 30 years later" (PDF). In Carreño, V.; Muñoz, C.; Tahar, S. (eds.). Proceedings, 15th International Conference TPHOL. LNCS. 2410. Springer. pp. 3–12.
^ Wells, J. B. (1993). "Typability and type checking in the second-order lambda-calculus are equivalent and undecidable". Tech. Rep. 93-011. CiteSeerX 10.1.1.31.3590.
^ Leroy, Xavier (17 September 2018). "The Compcert verified compiler".
^ Simon Peyton Jones; Dimitrios Vytiniotis; Stephanie Weirich; Geoffrey Washburn (April 2006). "Simple unification-based type inference for GADTs". Icfp 2006: 50–61.
^ Andrew Kennedy; Claudio Russo (October 2005). Generalized Algebraic Data Types and Object-Oriented Programming (PDF). OOPSLA. San Diego, California. ISBN
9781595930316
. Archived from the original (PDF) on 2006-12-29.
source of citation
^ Huges, John. "Why Functional Programming Matters" (PDF). chalmers.se/cse. Chalmers Tekniska H¨ogskola.
^ Purely functional data structures by Chris Okasaki, Cambridge University Press, 1998,
ISBN 0-521-66350-4
^ (hyPiRion), Jean Niklas L'orange. "polymatheia - Understanding Clojure's Persistent Vector, pt. 1". www.hypirion.com. Retrieved 2018-11-13.
^ Newbern, J. "All About Monads: A comprehensive guide to the theory and practice of monadic programming in Haskell". Retrieved 2008-02-14.
^ "Thirteen ways of looking at a turtle | F# for fun and profit". fsharpforfunandprofit.com. Retrieved 2018-11-13.
^ Larry C. Paulson (28 June 1996). ML for the Working Programmer. Cambridge University Press. ISBN
978-0-521-56543-1
. Retrieved 10 February 2013.
^ Daniel Spiewak (26 August 2008). "Implementing Persistent Vectors in Scala". Code Commit.
^ "Which programs are fastest? | Computer Language Benchmarks Game". benchmarksgame.alioth.debian.org. Archived from the original on 2013-05-20. Retrieved 2011-06-20.
^ Igor Pechtchanski; Vivek Sarkar (2005). "Immutability specification and its applications". Concurrency and Computation: Practice and Experience. 17 (5–6): 639–662. doi:10.1002/cpe.853.
^ "Chapter 25. Profiling and optimization". Book.realworldhaskell.org. Retrieved 2011-06-20.
^ Thorp, Noah (16 February 2008). "Fibonacci Sequence Recursion in Erlang". Aquabu. Archived from the original on 26 December 2013.
^ Hartel, Pieter; Henk Muller; Hugh Glaser (March 2004). "The Functional C experience" (PDF). Journal of Functional Programming. 14 (2): 129–135. doi:10.1017/S0956796803004817.
; David Mertz. "Functional programming in Python, Part 3". IBM developerWorks. Archived from the original on 2007-10-16. Retrieved 2006-09-17.
(Part 1, Part 2)
^ "Functions — D Programming Language 2.0". Digital Mars. 30 December 2012.
^ "Lua Unofficial FAQ (uFAQ)".
^ Eich, Brendan (3 April 2008). "Popularity".
^ van Rossum, Guido (2009-04-21). "Origins of Python's "Functional" Features". Retrieved 2012-09-27.
^ "functools — Higher order functions and operations on callable objects". Python Software Foundation. 2011-07-31. Retrieved 2011-07-31.
^ Skarsaune, Martin (2008). The SICS Java Port Project Automatic Translation of a Large Object Oriented System from Smalltalk to Java.
^ Gosling, James. "Closures". James Gosling: on the Java Road. Oracle. Archived from the original on 2013-04-14. Retrieved 11 May 2013.
^ Williams, Michael (8 April 2013). "Java SE 8 Lambda Quick Start".
^ Bloch, Joshua (2008). "Item 15: Minimize Mutability". Effective Java (Second ed.). Addison-Wesley. ISBN
978-0321356680
.
^ Odersky, Martin; Spoon, Lex; Venners, Bill (December 13, 2010). Programming in Scala: A Comprehensive Step-by-step Guide (2nd ed.). Artima. pp. 883/852. ISBN
978-0-9815316-4-9
.
^ Ray, Baishakhi; Posnett, Daryl; Devanbu, Premkumar; Filkov, Vladimir (2017-09-25). "A large-scale study of programming languages and code quality in GitHub". Communications of the ACM. 60 (10): 92. doi:10.1145/3126905.
^ Piro, Christopher (2009). Functional Programming at Facebook. CUFP 2009. Archived from the original on 2009-10-17. Retrieved 2009-08-29.
^ "Sim-Diasca: a large-scale discrete event concurrent simulation engine in Erlang". November 2011.
^ 1 million is so 2011 // WhatsApp blog, 2012-01-06: "the last important piece of our infrastracture is Erlang"
^ Momtahan, Lee (2009). Scala at EDF Trading: Implementing a Domain-Specific Language for Derivative Pricing with Scala. CUFP 2009. Archived from the original on 2009-10-17. Retrieved 2009-08-29.
^ Graham, Paul (2003). "Beating the Averages". Retrieved 2009-08-29.
^ Sims, Steve (2006). Building a Startup with Standard ML (PDF). CUFP 2006. Retrieved 2009-08-29.
^ Laurikari, Ville (2007). Functional Programming in Communications Security. CUFP 2007. Retrieved 2009-08-29.
^ Lorimer, R. J. (19 January 2009). "Live Production Clojure Application Announced". InfoQ.
^ Emmanuel Schanzer of Bootstrap interviewed on the TV show Triangulation on the TWiT.tv network
Further reading[edit]
Abelson, Hal; Sussman, Gerald Jay (1985). Structure and Interpretation of Computer Programs. MIT Press.
Cousineau, Guy and Michel Mauny. The Functional Approach to Programming. Cambridge, UK: Cambridge University Press, 1998.
Curry, Haskell Brooks and Feys, Robert and Craig, William. Combinatory Logic. Volume I. North-Holland Publishing Company, Amsterdam, 1958.
Curry, Haskell B.; Hindley, J. Roger; Seldin, Jonathan P. (1972). Combinatory Logic. Vol. II. Amsterdam: North Holland. ISBN
978-0-7204-2208-5
.
Dominus, Mark Jason. Higher-Order Perl. Morgan Kaufmann. 2005.
Felleisen, Matthias; Findler, Robert; Flatt, Matthew; Krishnamurthi, Shriram (2001). How to Design Programs. MIT Press.
Graham, Paul. ANSI Common LISP. Englewood Cliffs, New Jersey: Prentice Hall, 1996.
MacLennan, Bruce J. Functional Programming: Practice and Theory. Addison-Wesley, 1990.
O'Sullivan, Brian; Stewart, Don; Goerzen, John (2008). Real World Haskell. O'Reilly.
Pratt, Terrence, W. and Marvin V. Zelkowitz. Programming Languages: Design and Implementation. 3rd ed. Englewood Cliffs, New Jersey: Prentice Hall, 1996.
Salus, Peter H. Functional and Logic Programming Languages. Vol. 4 of Handbook of Programming Languages. Indianapolis, Indiana: Macmillan Technical Publishing, 1998.
Thompson, Simon. Haskell: The Craft of Functional Programming. Harlow, England: Addison-Wesley Longman Limited, 1996.
External links[edit]
Listen to this article (info/dl)


This audio file was created from a revision of the article "Functional programming" dated 2011-08-25, and does not reflect subsequent edits to the article. (Audio help)
More spoken articles
Ford, Neal (2012-01-29). "Functional thinking: Why functional programming is on the rise". Retrieved 2013-02-24.
Akhmechet, Slava (2006-06-19). "defmacro – Functional Programming For The Rest of Us". Retrieved 2013-02-24.
An introduction
Functional programming in Python (by David Mertz): part 1, part 2, part 3
v
t
e
Types of programming languages
Actor-based
Array
Aspect-oriented
Class-based
Concatenative
Concurrent
Dataflow
Declarative
Domain-specific
Dynamic
Esoteric
Event-driven
Extensible
Functional
Imperative
Logic
Macro
Metaprogramming
Multi-paradigm
Object-based
Object-oriented
Pipeline
Procedural
Prototype-based
Reflective
Rule-based
Scripting
Stack based
Synchronous
Tactile
Templating
Assembly
Compiled
Interpreted
Machine
Low-level
High-level
Very high-level
First generation
Second generation
Third generation
Fourth generation
Fifth generation
Non-English-based
Visual
Authority control
BNE: XX547935
BNF: cb121910539 (data)
GND: 4198740-8
LCCN: sh87007844